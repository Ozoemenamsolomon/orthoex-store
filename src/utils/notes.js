// <!-- discussions -->
// - show 9am - 10:20 am
// - break between slots - 10 mins
// - Reduce location button by at least half
// - selected date should be orange
// - spacing between 1st and 2nd column and 2nd and 3rd column should be the same
// - Remove headers i.e. Home composite e.t.column
// - if status cancelled. make the lot available for booking. Otherwise, slot should ne be avaible it exists in the appointment table (using locationID, date and start time, status)
// - Default state when booked is Check-in
// - appointment status: (booked, cancelled, checked-in) json (status, userID, fullname, update date time)


// <!-- activity history -->

// CREATE TABLE IF NOT EXISTS public."activityHistory"
// (
//     "activityId" bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
//     "createdAt" timestamp with time zone NOT NULL DEFAULT now(),
//     "customerEmail" text COLLATE pg_catalog."default",
//     "activityType" json,
//     CONSTRAINT "activityHistory_pkey" PRIMARY KEY ("activityId")
// )

// TABLESPACE pg_default;

// ALTER TABLE public."activityHistory"
//     OWNER to postgres;

const activityHistory = {
  activityId: 1,
  createdAt: new Date(), 
  customerEmail: 'example@email.com', 
  activityType: {
    // Replace with the actual structure for "activityType" based on your use case
    // Example:
    action: 'some_action',
    details: 'some_details',
  },
};


// <!-- appointment -->

// CREATE TABLE IF NOT EXISTS public.appointment
// (
//     id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
//     created_at timestamp with time zone NOT NULL DEFAULT now(),
//     "locationId" bigint,
//     "locationName" text COLLATE pg_catalog."default",
//     "user" json,
//     "customerId" text COLLATE pg_catalog."default",
//     "customerName" text COLLATE pg_catalog."default",
//     "customerSurname" text COLLATE pg_catalog."default",
//     "customerType" text COLLATE pg_catalog."default",
//     "appointmentDate" date,
//     "AppointmentStartTime" timestamp without time zone,
//     status json,
//     CONSTRAINT appointment_pkey PRIMARY KEY (id)
// )

// TABLESPACE pg_default;

// ALTER TABLE public.appointment
//     OWNER to postgres;


const appointment = {
  id: 1,
  created_at: new Date(),
  locationId: 123,
  locationName: 'Example Location',
  user: {
    userId: 456,
    userName: 'John Doe',
  },
  customerId: 'customer123',
  customerName: 'CustomerFirstName',
  customerSurname: 'CustomerLastName',
  customerType: 'Regular',
  appointmentDate: '2023-01-01',
  AppointmentStartTime: '2023-01-01T10:00:00',
  status: {
    statusCode: 'confirmed',
    statusDetails: 'Appointment confirmed',
  },
};

// booking price

// CREATE TABLE IF NOT EXISTS public."bookingPrice"
// (
//     id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
//     created_at timestamp with time zone NOT NULL DEFAULT now(),
//     "organisationId" text COLLATE pg_catalog."default",
//     plan text COLLATE pg_catalog."default",
//     price numeric,
//     CONSTRAINT "bookingPrice_pkey" PRIMARY KEY (id)
// )

// TABLESPACE pg_default;

// ALTER TABLE public."bookingPrice"
//     OWNER to postgres;

// fetch this data from table bookingPrice
const bookingPrice = {
  id: 1,
  created_at: new Date(),
  organisationId: 'org123',
  plan: 'Basic Plan',
  price: 29.99,
};


// holidays

// CREATE TABLE IF NOT EXISTS public.holidays
// (
//     id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
//     created_at timestamp with time zone NOT NULL DEFAULT now(),
//     "locationId" bigint,
//     date date,
//     "closedAllDay" boolean,
//     "startTime" timestamp with time zone,
//     "endTime" timestamp with time zone,
//     CONSTRAINT holidays_pkey PRIMARY KEY (id)
// )

// TABLESPACE pg_default;

// ALTER TABLE public.holidays
//     OWNER to postgres;

const holiday = {
  id: 1,
  created_at: new Date(),
  locationId: 123,
  date: '2023-01-01',
  closedAllDay: true,
  startTime: '2023-01-01T09:00:00',
  endTime: '2023-01-01T17:00:00',
};

// location

// CREATE TABLE IF NOT EXISTS public.location
// (
//     "locationId" bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
//     created_at timestamp with time zone NOT NULL DEFAULT now(),
//     "locationName" text COLLATE pg_catalog."default",
//     "locationAddress" text COLLATE pg_catalog."default",
//     "organisationName" text COLLATE pg_catalog."default",
//     "organisationLogo" text COLLATE pg_catalog."default",
//     "bookingDuration" numeric,
//     "maxBookingPerSlot" numeric,
//     "startTime" time with time zone,
//     "totalSlotsPerDay" numeric,
//     "breakBetweenSlots" numeric,
//     "availableSaturday" boolean,
//     "availableSunday" boolean,
//     "organisationId" text COLLATE pg_catalog."default",
//     CONSTRAINT location_pkey PRIMARY KEY ("locationId")
// )

// fetch locations
const location = {
  locationId: 1,
  created_at: new Date(),
  locationName: 'Example Location',
  locationAddress: '123 Main Street, City, Country',
  organisationName: 'Example Organization',
  organisationLogo: 'path/to/logo.png',
  bookingDuration: 30, // in minutes
  maxBookingPerSlot: 5,
  startTime: '09:00:00', // assuming a string representation of time
  totalSlotsPerDay: 10,
  breakBetweenSlots: 15, // in minutes
  availableSaturday: true,
  availableSunday: false,
  organisationId: 'org123',
};


// Add handleAuth() to your app, which creates the following route handlers under the hood that perform different parts of the authentication flow:

// /api/auth/login: Your Next.js application redirects users to your identity provider for them to log in (you can optionally pass a returnTo parameter to return to a custom relative URL after login, for example /api/auth/login?returnTo=/profile).
// /api/auth/callback: Your identity provider redirects users to this route after they successfully log in.
// /api/auth/logout: Your Next.js application logs out the user.
// /api/auth/me: You can fetch user profile information in JSON format.